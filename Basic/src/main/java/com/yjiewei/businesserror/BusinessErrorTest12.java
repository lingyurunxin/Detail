package com.yjiewei.businesserror;

/**
 * 12 | 异常处理：别让自己在出问题的时候变为瞎子
 * @author yangjiewei
 * @date 2022/9/1
 */
public class BusinessErrorTest12 {
    /*
    * 捕获和处理异常容易犯的错
    *   “统一异常处理”方式正是我要说的第一个错：不在业务代码层面考虑异常处理，仅在框架层面粗犷捕获和处理异常。
    *       从业务性质上异常可以分为业务异常和系统异常。
    *       日志记录可以将相关出入参记录，用户信息需要脱敏，这样方便出问题时根据上下文进行排查。
    *   第二个错：捕获了异常直接生吞，直接丢弃异常不记录，不抛出，这样排查问题异常艰难。
    *   第三个错：丢弃异常的原始信息，这也是重要信息，包括异常类型及堆栈信息。
    *   第四个错：抛出异常时不指定任何信息，排查的时候还可能以为哪里空指针导致。
    *   第五个错：千万别把异常定义为静态变量
    *
    *   正确操作：
    *       1.日志正确记录原始异常信息；
    *       2.转换成新异常抛出，最好有分类和明确的异常消息；
    *       3.重试。如果调用远程服务超时的情况，可以进行重试操作；
    *       4.恢复。即尝试进行降级处理，或使用默认值替换原始数据。
    *
    *   finally中的异常
    *       1.try块中的异常会被finally中的异常覆盖。一个方法无法抛出两个异常。
    *       2.finally中的异常也需要自己控制。
    *       3.或者把finally块的异常附加到try(主)的异常，通过addSuppressed(e).这种方式对于实现了AutoCloseable接口的资源一致。
    *       4.可以使用try with resources
    *
    *   多线程中的异常没看明白...
    * */
}
